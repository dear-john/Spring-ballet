/*(1) m > n 
在整数划分中实际上最大加数不能大于n，因此在这种情况可以等价为judge(n, n); 
可用程序表示为if(m > n) return judge(n, n); 
(2) m = n 
这种情况可用递归表示为judge(n, m - 1) + 1，从以上例子中可以看出，就是最大加 
数为6和小于6的划分之和 
用程序表示为if(m == n) return (judge(n, m - 1) + 1); 
(3) m < n 
这是最一般的情况，在划分的大多数时都是这种情况。 
从上例可以看出，设m = 4，那judge(6, 4)的值是最大加数小于4划分数和整数2的划分数的和。 
因此，judge(n, m)可表示为judge(n, m - 1) + judge(n - m, m)
*/

//使用数组进行缓存，提高效率，并且每次输入都要进行重新赋值
#include<iostream>
using namespace std;
int a[125][125];
int fun(int n,int m){
	if(a[n][m]!=-1)return a[n][m];
	else if(n<1||m<1) return a[n][m]=0;
	else if(n==1||m==1)return a[n][m]=1;
	else if(n==m)return a[n][m]=1+fun(n,m-1);
	else if(m>n)return a[n][m]=fun(n,n);
	else return a[n][m]=(fun(n,m-1)+fun(n-m,m));
}
int main(){
	//
	int n;
	while(cin>>n){
		for(int i=0;i<125;i++)
		for(int j=0;j<125;j++)
			a[i][j]=-1;
		cout<<fun(n,n)<<endl;
	}
	//
	return 0;
}
